using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace StronglyTypedPrimitives;

internal static class Emitter
{
    public static string CodeHeader { get; } = """
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated by a tool.
        //
        //     Changes to this file may cause incorrect behavior and will be lost if
        //     the code is regenerated.
        // </auto-generated>
        //------------------------------------------------------------------------------
        #nullable enable

        """;

    public const string StronglyTypedPrimitivesNamespace = "StronglyTypedPrimitives";

    public static string IStronglyTypedPrimitive => $"global::{StronglyTypedPrimitivesNamespace}.IStronglyTypedPrimitive";

    public static string GeneratedCodeConstructor => $@"System.CodeDom.Compiler.GeneratedCodeAttribute(""{typeof(StronglyTypedPrimitiveGenerator).Assembly.FullName}"", ""{typeof(StronglyTypedPrimitiveGenerator).Assembly.GetName().Version}"")";

    public static string GeneratedCodeAttribute => $"[{GeneratedCodeConstructor}]";

    public static string GetStronglyTypedPrimitiveAttributeSource() => $$"""
        {{CodeHeader}}

        namespace {{StronglyTypedPrimitivesNamespace}};
        
        {{GeneratedCodeAttribute}}
        [global::System.AttributeUsage(global::System.AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
        public sealed class StronglyTypedAttribute : global::System.Attribute { }
        """;

    public static string GetIStronglyTypedPrimitiveSource() => $$"""
        {{CodeHeader}}

        namespace {{StronglyTypedPrimitivesNamespace}};

        {{GeneratedCodeAttribute}}
        public interface IStronglyTypedPrimitive
        {
        }       
        """;

    internal static string? GetNamespaceDefinition(StronglyTypedTypeInfo info)
        => info.Namespace is not null
            ? $"namespace {info.Namespace};\n"
            : null;

    internal static string GetTargetRecordStructDefinition(StronglyTypedTypeInfo info, SemanticModel semanticModel)
    {
        var includeIParsable = Parser.IsUnderlyingTypeIParsableOrString(
            semanticModel,
            semanticModel.GetTypeInfo(info.UnderlyingType).Type!);

        return includeIParsable
            ? $$"""
                {{info.Target.Modifiers}} record struct {{info.Target.Identifier}} : {{IStronglyTypedPrimitive}}, global::System.IParsable<{{info.Target.Identifier}}>
                {
                """
            : $$"""
                {{info.Target.Modifiers}} record struct {{info.Target.Identifier}} : {{IStronglyTypedPrimitive}}
                {
                """;
    }

    internal static string GetNoneStaticField(StronglyTypedTypeInfo info, SemanticModel semanticModel)
    {
        var isStringType = Parser.IsUnderlyingTypeString(info, semanticModel);
        var defaultValue = isStringType ? "string.Empty" : "default";
        return $"""
            public static readonly {info.Target.Identifier} None = new {info.Target.Identifier}({defaultValue});
        """;
    }

    internal static string GetValuePropertyDefinition(StronglyTypedTypeInfo info)
    {
        var fieldName = $"@{info.Parameter.Identifier.ToString().ToLowerInvariant()}";
        return $$"""

            private readonly {{info.UnderlyingType}} {{fieldName}} = ThrowIfValueIsInvalid({{info.Parameter.Identifier}});       

            public {{info.UnderlyingType}} {{info.Parameter.Identifier}}
            {
                get => {{fieldName}};
                init
                {
                    {{fieldName}} = ThrowIfValueIsInvalid(value);
                }
            }

            private static {{info.UnderlyingType}} ThrowIfValueIsInvalid({{info.UnderlyingType}} value)
            {
                IsValueValid(value, throwIfInvalid: true);
                return value;
            }
        """;
    }

    internal static string? GetIsValueValidMethodDefinition(StronglyTypedTypeInfo info, SemanticModel semanticModel)
    {
        if (Parser.HasExistingIsValueValidMethod(info, semanticModel))
        {
            return null;
        }

        var validationAttributes = Parser.GetValidationAttributes(info.Parameter, semanticModel);
        var validatorsArray = string.Join(",\n        ", validationAttributes);
        if (validatorsArray.Length > 0)
        {
            return $$"""
                
                private static readonly global::System.ComponentModel.DataAnnotations.ValidationAttribute[] Validators =
                [
                    {{validatorsArray}}
                ];

                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
                public static bool IsValueValid({{info.UnderlyingType}} value, bool throwIfInvalid)
                {
                    for (var i = 0; i < Validators.Length; i++)
                    {
                        if (!Validators[i].IsValid(value))
                        {
                            return false;
                        }
                    }

                    return true;
                }
            """;
        }
        else
        {
            return $$"""

                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
                public static bool IsValueValid({{info.UnderlyingType}} value, bool throwIfInvalid) => true;
            """;
        }
    }

    public static string GetToStringDefinition(StronglyTypedTypeInfo info)
        => $$"""

            public override string ToString() => {{info.Parameter.Identifier}}.ToString();
        """;

    public static IEnumerable<string> GetIParsableDefinitions(StronglyTypedTypeInfo info, SemanticModel semanticModel)
    {
        var (hasParse, hasTryParse) = Parser.HasExistingIParsableImplementation(info, semanticModel);

        if (hasParse && hasTryParse)
        {
            yield break;
        }

        var underlyingTypeSymbol = semanticModel.GetTypeInfo(info.UnderlyingType).Type;
        var isStringType = underlyingTypeSymbol?.SpecialType == SpecialType.System_String;

        if (!hasParse && !isStringType)
        {
            yield return $$"""

                public static {{info.Target.Identifier}} Parse(string? s, global::System.IFormatProvider? provider)
                {
                    var rawValue = {{info.UnderlyingType}}.Parse(s!, provider);
                    IsValueValid(rawValue, throwIfInvalid: true);
                    return new {{info.Target.Identifier}}(rawValue);
                }
            """;
        }
        if (!hasParse && isStringType)
        {
            yield return $$"""

                public static {{info.Target.Identifier}} Parse(string? s, global::System.IFormatProvider? provider)
                {
                    global::System.ArgumentNullException.ThrowIfNull(s);
                    IsValueValid(s, throwIfInvalid: true);
                    return new {{info.Target.Identifier}}(s);
                }
            """;
        }

        if (!hasTryParse && !isStringType)
        {
            yield return $$"""

                public static bool TryParse(string? s, global::System.IFormatProvider? provider, out {{info.Target.Identifier}} result)
                {
                    if ({{info.UnderlyingType}}.TryParse(s, provider, out var rawValue) && IsValueValid(rawValue, throwIfInvalid: false))
                    {
                        result = new {{info.Target.Identifier}}(rawValue);
                        return true;
                    }

                    result = default;
                    return false;
                }
            """;
        }

        if (!hasTryParse && isStringType)
        {
            yield return $$"""
    
                public static bool TryParse(string? s, global::System.IFormatProvider? provider, out {{info.Target.Identifier}} result)
                {
                    if (s is not null && IsValueValid(s, throwIfInvalid: false))
                    {
                        result = new {{info.Target.Identifier}}(s);
                        return true;
                    }

                    result = default;
                    return false;
                }
            """;
        }
    }
}

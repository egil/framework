using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace StronglyTypedPrimitives;

[Generator]
public sealed class StronglyTypedPrimitiveGenerator : IIncrementalGenerator
{
    public const string StronglyTypedPrimitivesNamespace = "StronglyTypedPrimitives";

    public static string IStronglyTypedPrimitive => $"global::{StronglyTypedPrimitivesNamespace}.IStronglyTypedPrimitive";

    public static string GeneratedCodeConstructor => $@"System.CodeDom.Compiler.GeneratedCodeAttribute(""{typeof(StronglyTypedPrimitiveGenerator).Assembly.FullName}"", ""{typeof(StronglyTypedPrimitiveGenerator).Assembly.GetName().Version}"")";

    public static string GeneratedCodeAttribute => $"[{GeneratedCodeConstructor}]";

    public static string GeneratedCodeHeader => """
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated by a tool.
        //
        //     Changes to this file may cause incorrect behavior and will be lost if
        //     the code is regenerated.
        // </auto-generated>
        //------------------------------------------------------------------------------
        #nullable enable
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("StronglyTypedPrimitiveAttribute.g.cs", GetStronglyTypedPrimitiveAttributeSource());
            ctx.AddSource("IStronglyTypedPrimitive.g.cs", GetIStronglyTypedPrimitiveSource());
        });

        var recordCandidates = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) =>
                    node is RecordDeclarationSyntax r &&
                    r.Modifiers.Any(SyntaxKind.PartialKeyword) &&
                    r.AttributeLists.Count > 0,
                transform: static (context, _) =>
                {
                    var recordDecl = (RecordDeclarationSyntax)context.Node;
                    var model = context.SemanticModel;
                    return model.GetDeclaredSymbol(recordDecl) is INamedTypeSymbol symbol
                        && symbol.GetAttributes().Any(IsStronglyTypedPrimitiveAttribute)
                        ? recordDecl
                        : null;
                }
            )
            .Where(static m => m is not null);

        var compilationAndRecords = context.CompilationProvider.Combine(recordCandidates.Collect());

        context.RegisterSourceOutput(compilationAndRecords, (spc, source) =>
        {
            var (compilation, records) = source;
            foreach (var recordDecl in records)
            {
                // Only support record struct with a single parameter named "Value"
                if (recordDecl is null
                 || recordDecl?.ParameterList?.Parameters.Count != 1
                 || recordDecl?.ParameterList?.Parameters[0].Type is not { } paramType
                 || recordDecl?.ParameterList?.Parameters[0].Identifier.Text != "Value")
                {
                    continue;
                }

                var generatedSource = GenerateTypeSource(recordDecl, paramType, compilation);
                spc.AddSource($"{recordDecl.Identifier.Text}.g.cs", generatedSource);
            }
        });
    }

    private static string GenerateTypeSource(RecordDeclarationSyntax recordDecl, TypeSyntax underlyingType, Compilation compilation)
    {
        var @namespace = GetNamespaceDefinition(recordDecl);
        var targetTypeName = recordDecl.Identifier;
        var targetTypeFullName = @namespace is not null ? $"{@namespace}.{targetTypeName}" : targetTypeName.ToString();

        return $$"""
            {{GeneratedCodeHeader}}

            {{(@namespace is not null ? $"namespace {@namespace};" : "")}}

            {{GeneratedCodeAttribute}}
            {{recordDecl.Modifiers}} record struct {{targetTypeName}} :
                {{IStronglyTypedPrimitive}}
            {
                public static readonly {{targetTypeName}} None = new {{targetTypeName}}(default);
                {{GenerateIsValidMethod(recordDecl, targetTypeName, compilation)}}

                public {{underlyingType}} Value { get; init; } = ThrowIfInvalid(Value);

                private static {{underlyingType}} ThrowIfInvalid({{underlyingType}} value)
                {
                    if (!IsValid(value))
                    {
                        throw new global::System.ArgumentException($"The value '{value}' is not valid for {{targetTypeName}}.", "Value");
                    }

                    return value;
                }
            }
            """;
    }

    // Modified HasExistingIsValidMethod to check underlying type of "Value"
    private static bool HasExistingIsValidMethod(RecordDeclarationSyntax recordDecl, SemanticModel semanticModel)
    {
        var typeSymbol = semanticModel.GetDeclaredSymbol(recordDecl)!;
        var valueParameter = recordDecl.ParameterList!.Parameters[0];
        var underlyingTypeSymbol = semanticModel.GetTypeInfo(valueParameter.Type).Type;
        return typeSymbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Any(m => m.Name == "IsValid"
                && m.IsStatic
                && m.Parameters.Length == 1
                && m.Parameters[0].Type.Equals(underlyingTypeSymbol, SymbolEqualityComparer.Default));
    }

    // Modified GenerateIsValidMethod to use underlying type, not the target type
    private static string GenerateIsValidMethod(RecordDeclarationSyntax recordDecl, SyntaxToken targetTypeName, Compilation compilation)
    {
        var semanticModel = compilation.GetSemanticModel(recordDecl.SyntaxTree);
        var valueParameter = recordDecl.ParameterList!.Parameters[0];
        string underlyingTypeText = valueParameter.Type!.ToString();

        if (HasExistingIsValidMethod(recordDecl, semanticModel))
        {
            return string.Empty;
        }

        var validationAttributes = GetValidationAttributes(valueParameter, semanticModel);
        var validatorsArray = string.Join(",\n        ", validationAttributes);
        if (validatorsArray.Length > 0)
        {
            return $$"""
                private static readonly global::System.ComponentModel.DataAnnotations.ValidationAttribute[] Validators =
                [
                    {{validatorsArray}}
                ];

                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
                public static bool IsValid({{underlyingTypeText}} value)
                {
                    for (var i = 0; i < Validators.Length; i++)
                    {
                        if (!Validators[i].IsValid(value))
                        {
                            return false;
                        }
                    }

                    return true;
                }
            """;
        }
        else
        {
            return $$"""

                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
                public static bool IsValid({{underlyingTypeText}} value) => true;            
            """;
        }
    }

    private static IEnumerable<string> GetValidationAttributes(ParameterSyntax parameter, SemanticModel semanticModel)
    {
        var parameterSymbol = semanticModel.GetDeclaredSymbol(parameter);
        if (parameterSymbol == null) yield break;

        foreach (var attribute in parameterSymbol.GetAttributes())
        {
            if (!IsValidationAttribute(attribute)) continue;

            var constructorArgs = GetAttributeConstructorArgs(attribute);
            var namedArgs = string.Join(", ", attribute.NamedArguments.Select(na => $"{na.Key} = {na.Value.ToCSharpString()}"));
            var args = string.Join(", ", new[] { constructorArgs, namedArgs }.Where(s => !string.IsNullOrEmpty(s)));
            yield return $"new global::{attribute.AttributeClass!.ToDisplayString()}({args})";
        }
    }

    private static string GetAttributeConstructorArgs(AttributeData attribute)
    {
        var constructor = attribute.AttributeConstructor;
        if (constructor == null) return string.Empty;

        var args = new List<string>();
        var paramsParameter = constructor.Parameters.FirstOrDefault(p => p.IsParams);

        if (paramsParameter == null)
        {
            // No params parameter, handle normally
            return string.Join(", ", attribute.ConstructorArguments.Select(arg => arg.ToCSharpString()));
        }

        // Handle regular arguments before params array
        var paramsArrayStart = constructor.Parameters.IndexOf(paramsParameter);
        for (var i = 0; i < paramsArrayStart; i++)
        {
            args.Add(attribute.ConstructorArguments[i].ToCSharpString());
        }

        // Handle params array
        if (attribute.ConstructorArguments.Length > paramsArrayStart)
        {
            var paramsArg = attribute.ConstructorArguments[paramsArrayStart];
            if (paramsArg.Kind == TypedConstantKind.Array)
            {
                // If we have multiple values, create an array
                var values = paramsArg.Values.Select(v => v.ToCSharpString());
                if (values.Any())
                {
                    if (values.Count() > 1)
                    {
                        args.Add($"new [] {{{string.Join(", ", values)}}}");
                    }
                    else
                    {
                        args.Add(values.First());
                    }
                }
            }
            else
            {
                // Single argument passed to params
                args.Add(paramsArg.ToCSharpString());
            }
        }

        return string.Join(", ", args);
    }

    private static bool IsValidationAttribute(AttributeData attribute)
    {
        var baseType = attribute.AttributeClass?.BaseType;
        while (baseType != null)
        {
            if (baseType.ToDisplayString() == "System.ComponentModel.DataAnnotations.ValidationAttribute")
                return true;
            baseType = baseType.BaseType;
        }
        return false;
    }

    private static string? GetNamespaceDefinition(RecordDeclarationSyntax structSymbol)
    {
        // determine the namespace the struct is declared in, if any
        SyntaxNode? potentialNamespaceParent = structSymbol.Parent;
        while (potentialNamespaceParent is not null
            && potentialNamespaceParent is not NamespaceDeclarationSyntax
            && potentialNamespaceParent is not FileScopedNamespaceDeclarationSyntax)
        {
            potentialNamespaceParent = potentialNamespaceParent.Parent;
        }

        if (potentialNamespaceParent is BaseNamespaceDeclarationSyntax namespaceParent)
        {
            string nameSpace = namespaceParent.Name.ToString();
            while (true)
            {
                if (namespaceParent.Parent is not NamespaceDeclarationSyntax namespaceParentParent)
                {
                    break;
                }

                namespaceParent = namespaceParentParent;
                nameSpace = $"{namespaceParent.Name}.{nameSpace}";
            }

            return nameSpace;
        }

        return null;
    }

    private static bool IsStronglyTypedPrimitiveAttribute(AttributeData attribute)
        => attribute.AttributeClass?.Name == "StronglyTypedPrimitive"
        || attribute.AttributeClass?.Name == "StronglyTypedPrimitiveAttribute";

    private static string GetStronglyTypedPrimitiveAttributeSource() => $$"""
        {{GeneratedCodeHeader}}

        namespace {{StronglyTypedPrimitivesNamespace}};
        
        {{GeneratedCodeAttribute}}
        [global::System.AttributeUsage(global::System.AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
        public sealed class StronglyTypedPrimitiveAttribute : global::System.Attribute { }
        """;

    private static string GetIStronglyTypedPrimitiveSource() => $$"""
        {{GeneratedCodeHeader}}

        namespace {{StronglyTypedPrimitivesNamespace}};

        {{GeneratedCodeAttribute}}
        public interface IStronglyTypedPrimitive
        {
        }       
        """;
}
